{
    parserClass="de.arrobait.antlers.parser.AntlersParser"
    parserUtilClass="de.arrobait.antlers.parser.AntlersParserUtil"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Antlers"
    psiImplClassSuffix="Impl"
    psiPackage="de.arrobait.antlers.psi"
    psiImplPackage="de.arrobait.antlers.psi.impl"

    elementTypeHolderClass="de.arrobait.antlers.psi.AntlersTypes"
    elementTypeClass="de.arrobait.antlers.psi.AntlersElementType"
    tokenTypeClass="de.arrobait.antlers.psi.AntlersTokenType"

    mixin("comment_block")="de.arrobait.antlers.psi.mixins.AntlersCommentMixin"

    tokens = [
        T_COMMENT_OPEN='{{#'
        T_COMMENT_CLOSE='#}}'

        T_PHP_RAW_OPEN='{{?'
        T_PHP_RAW_CLOSE='?}}'

        T_PHP_ECHO_OPEN='{{$'
        T_PHP_ECHO_CLOSE='$}}'

        T_LD='{{'
        T_RD='}}'
        T_LP='('
        T_RP=')'
        T_LEFT_BRACE='{'
        T_RIGHT_BRACE='}'
        T_LEFT_BRACKET='['
        T_RIGHT_BRACKET=']'

        T_TRUE='true'
        T_FALSE='false'

        T_PIPE='|'

        T_COLON=':'
        T_COMMA=','
        T_SEMICOLON=';'
        T_DOT='.'
        T_OP_EXCLAMATION_MARK='!'
        T_OP_QUESTIONMARK='?'
        T_OP_ASSIGN='='

        // Math
        T_OP_PLUS='+'
        T_OP_MINUS='-'
        T_OP_MUL='*'
        T_SLASH='/'
        T_OP_MOD='%'
        T_OP_POW='**'
        T_OP_SELF_ASSIGN_ADD='+='
        T_OP_SELF_ASSIGN_SUB='-='
        T_OP_SELF_ASSIGN_MUL='*='
        T_OP_SELF_ASSIGN_DIV='/='
        T_OP_SELF_ASSIGN_MOD='%='

        T_OP_EQ='=='
        T_OP_NEQ='!='
        T_OP_IDENT='==='
        T_OP_NOT_IDENT='!=='
        T_OP_LT='<'
        T_OP_LTE='<='
        T_OP_GT='>'
        T_OP_GTE='>='
        T_OP_SPACESHIP='<=>'
        T_OP_NULL_COALESCENCE='??'
        T_OP_GATEKEEPER='?='

        T_OP_AND='regexp:&&|and'
        T_OP_OR='regexp:\|\||or'
        T_OP_XOR='xor'

        T_IF='if'
        T_END_IF='endif'
        T_ELSE_IF='elseif'
        T_ELSE='else'
        T_IF_END='/if'
        T_UNLESS='unless'
        T_END_UNLESS='endunless'

        T_SWITCH='switch'
        T_OP_ARROW='=>'

        T_AT='@'
        T_NOPARSE='noparse'

        T_AS='as'

        T_GROUP_BY='groupby'
        T_MERGE='merge'
        T_ORDER_BY='orderby'
        T_PLUCK='pluck'
        T_SKIP='skip'
        T_TAKE='take'
        T_WHERE='where'

        T_TAXONOMY='taxonomy:'

        T_INTEGER_NUMBER='regexp:0|[1-9]\d*'
        T_FLOAT_NUMBER='regexp:\d*\.\d+([eE][-+]?\d+)?|\d+[eE][-+]?\d+'

        T_SINGLE_QUOTE="'"
        T_DOUBLE_QUOTE='"'
        T_STRING_CONTENT="regexp:([^\\']|\\([\\'\"/bfnrt]|u[a-fA-F0-9]{4}))*"
    ]

    extends(".*expr")=expr
    extends(".*sub_expression")=expr
    extends(".*interpolated_statement")=expr
}

antlersFile ::= <<eof>> | [tines]
tines ::= (block_wrapper
        | antlers_close_node
        | switch_node
        | tag_single
        | noparse_region
        | variable_assignment_node
        | recursive_children_node
        | tine
        | comment_block
        | unclosed_comment
        | php_node
        | outer_content)*

tine ::= node_opener antlers_expression_or_statement  node_closer {
    pin=2
    recoverWhile=antlers_node_recover
}
private antlers_node_recover ::= !(node_opener | outer_content | '{{#' | '{{?' | '{{$' | 'if' | 'else' | 'elseif' | 'endif' | 'unless' | 'endunless' | '/' | '[' | '{' | ':' | '=')

private antlers_expression_or_statement ::= expr ('|' modifier_list)*
antlers_close_node ::= node_opener (T_SLASH variable) node_closer { pin=2 }

// Modifier
// {{ summary | replace('It was', 'It was also') | replace('times', $noun) }}
modifier_list        ::= T_MODIFIER [modifier_params_list]
modifier_params_list ::= modifier_list_paren | modifier_list_colon | modifier_list_assign
private modifier_list_paren ::= '(' modifier_param (',' modifier_param)*  ')'
private modifier_list_colon ::= ':' modifier_param (':' modifier_param)*
// TODO For simplicity I used string_literal here as this it was the argument takes: {{ array_var modifier="param1|param2" }}
// TODO but I guess I can improve it to let the plugin know, that this are arguments to the modifier.
// TODO Question is: Does it blend or is should it be done on lexing or better on parsing level.
private modifier_list_assign ::= '=' string_literal
modifier_param       ::= literal_expr | array

// Tags

// Special noparse tag
noparse_region ::= noparse_region_open tines noparse_region_close { pin = 1 }
noparse_region_open ::= node_opener 'noparse' node_closer { pin=2 }
noparse_region_close ::= node_opener (T_SLASH 'noparse') node_closer { pin=2 }

/**
 * Tags
 */
// {{ %partial:blog/card for="5 minutes" }}
//tag_node ::= node_opener tag tag_parameters node_closer
//tag ::= [T_DISAMBIGUATION] tag_name T_SHORTHAND_SEPARATOR tag_method
//tag_name ::= 'partial'

tag_single ::= tag_node_open
tag_pair ::= tag_node_open tines tag_node_close { pin = 3 }
tag_node_open ::= node_opener tag_with_attributes [T_SLASH] node_closer { pin=3 }
tag_node_close ::= node_opener (T_SLASH tag) node_closer { pin=2 }

private tag_with_attributes ::= tag (tag_attribute_assignment | tag_taxonomy_condition)*

tag ::= [T_DISAMBIGUATION] (shorthand_tag | regular_tag)
private shorthand_tag ::= regular_tag T_SHORTHAND_SEPARATOR tag_method_part { pin=2 }
private regular_tag ::= tag_name
tag_name ::= T_TAG
tag_method_part ::= tag_method_name (T_SHORTHAND_SEPARATOR tag_method_name)*
private tag_method_name ::= T_TAG_METHOD_NAME

tag_attribute_assignment ::= T_DYNAMIC_BINDING* tag_attribute_key '=' tag_attribute_value
tag_attribute_key ::= T_IDENTIFIER [T_TAG_CONDITION]
tag_attribute_value ::= string_literal

tag_taxonomy_condition ::= T_TAXONOMY taxonomy_name '=' taxonomy_term
taxonomy_name ::= T_IDENTIFIER
taxonomy_term ::= string_literal

recursive_children_node ::= node_opener T_STAR T_RECURSIVE_CHILDREN [':' T_IDENTIFIER] T_STAR node_closer { pin=3 }

/**
 * Conditional
 */
block_wrapper ::= conditional
                | tag_pair
block_open_node ::= conditional_start
block_close_node ::= conditional_end

conditional               ::= block_open_node tines (conditional_elseif tines)* (conditional_else tines)? block_close_node { pin=1 }
private conditional_start ::= (conditional_if | conditional_unless)
conditional_end           ::= (slash_unless_if | endunless_endif)
conditional_if            ::= node_opener 'if' expr ('|' modifier_list)* node_closer { pin=2 }
conditional_unless        ::= node_opener 'unless' expr ('|' modifier_list)* node_closer { pin=2 }
conditional_elseif        ::= node_opener 'elseif' expr ('|' modifier_list)* node_closer { pin=2 }
conditional_else          ::= node_opener 'else' node_closer { pin=2 }
private slash_unless_if   ::= node_opener (T_END_UNLESS | T_END_IF) node_closer { pin=2 }
private endunless_endif   ::= node_opener ('endunless' | 'endif') node_closer { pin=2 }

switch_node  ::= node_opener switch_tag node_closer { pin=2 }
switch_tag   ::= 'switch' '(' switch_case+ default_case? ')' { pin=1}
switch_case  ::= '(' group_comp ')' '=>' string_literal ','? { pin=4 }
default_case ::= '(' ')' '=>' string_literal ','? { pin=4 }

// Expressions
expr ::= interpolated_statement
       | group_bool
       | group_comp
       | group_add
       | group_mul
       | pow_expr
       | group_unary
       | concat_expr
       | group_primary
       | tenary_expr

private group_bool ::= and_expr | or_expr | xor_expr
private group_comp ::= eq_expr
                     | neq_expr
                     | ident_expr
                     | not_ident_expr
                     | lt_expr
                     | lte_expr
                     | gt_expr
                     | gte_expr
                     | spaceship_expr
                     | null_coalescing_expr
                     | gatekeeper_expr
                     | tenary_expr
private group_mul     ::= mul_expr | div_expr | mod_expr
private group_add     ::= add_expr | sub_expr
private group_unary   ::= unary_minus_expr | unary_not_expr | unary_factorial_expr
private group_primary ::= literal_expr | sub_expression

// Boolean
and_expr    ::= expr ('&&' | 'and') expr
or_expr     ::= expr ('||' | 'or') expr
xor_expr    ::= expr 'xor' expr

// Comparison
eq_expr              ::= expr '==' expr
neq_expr             ::= expr '!=' expr
ident_expr           ::= expr '===' expr
not_ident_expr       ::= expr '!==' expr
lt_expr              ::= expr '<' expr
lte_expr             ::= expr '<=' expr
gt_expr              ::= expr '>' expr
gte_expr             ::= expr '>=' expr
null_coalescing_expr ::= expr '??' expr
gatekeeper_expr      ::= expr '?=' expr
spaceship_expr       ::= expr '<=>' expr
tenary_expr ::= expr '?' expr ':' expr

// Math
mul_expr ::= expr ('*' | '*=') expr
div_expr ::= expr (T_SLASH | T_OP_SELF_ASSIGN_DIV) expr
mod_expr ::= expr ('%' | '%=') expr
add_expr ::= expr ('+' | '+=') expr
sub_expr ::= expr ('-' | '-=') expr
pow_expr ::= expr '**' expr

// Concat
concat_expr ::= string_literal '+' string_literal
              | number_literal '+' string_literal
              | string_literal '+' number_literal
              | string_literal '+' variable
              | variable ('+' | '+=') string_literal

// Unary
unary_minus_expr     ::= '-' expr
unary_not_expr       ::= '!' expr
unary_factorial_expr ::= expr '!'

// Variable
variable ::= '@'? (T_IDENTIFIER | T_SLOT) [property_access*]
private property_access ::= bracket_property_access | dot_property_access | colon_property_access
bracket_property_access ::= '[' (T_INTEGER_NUMBER | T_IDENTIFIER [dot_property_access | colon_property_access] | string_literal | interpolated_statement) ']'
dot_property_access     ::= '.' (T_INTEGER_NUMBER | T_IDENTIFIER | string_literal)
colon_property_access   ::= ':' (T_INTEGER_NUMBER | T_IDENTIFIER | string_literal)

// TODO: Extract the access key into own rule
//private property_access_keys ::= T_INTEGER_NUMBER | T_IDENTIFIER | string_literal

// {{ total = 0 }}
// {{ todo = ['Get haircut', 'Bake bread', 'Eat soup'] }}
variable_assignment_node ::= node_opener variable T_OP_ASSIGN assignable_items node_closer { pin=3 }
private assignable_items ::= boolean_literal
                           | number_literal
                           | string_literal
                           | variable [advanced_operators]
                           | array
                           | interpolated_statement [advanced_operators]
                           | sub_expression

variable_attribute_assignment ::= T_IDENTIFIER T_OP_ASSIGN string_literal  { pin=2 }

// Advanced operators
private advanced_operators ::= single_advanced_operator*

single_advanced_operator ::= groupby
                           | merge
                           | orderby
                           | pluck
                           | skip
                           | take
                           | where

groupby            ::= 'groupby' (groupby_args_list | groupby_args_list_with_arrow_func)
groupby_args_list  ::= '(' groupby_arg (',' groupby_arg)* ')' ['as' string_literal]
private groupby_args_list_with_arrow_func ::= '(''(' arrow_func groupby_arg [',' groupby_arg] ')'')' ['as' string_literal]
groupby_arg        ::= antlers_expression_or_statement [groupby_alias]
// TODO I am using a string for easier first implementation. Better is to change it to dedicated token stream like T_SINGLE_QUOTE T_TBD T_SINGLE_QUOTE
// TODO Maybe a good opportunity to refactor the string_literal and return dedicated tokens for single and double quotes
groupby_alias      ::= string_literal

// The merge operator can merge two or more "array-like" variables or expressions.
merge              ::= 'merge' (variable | interpolated_statement)

orderby            ::= 'orderby' '(' orderby_args_list ')'
orderby_args_list  ::= orderby_arg (',' orderby_arg)*
orderby_arg        ::= variable orderby_direction
orderby_direction  ::= string_literal | boolean_literal | variable

pluck              ::= 'pluck' '(' (variable | number_literal | string_literal) ')'
skip               ::= 'skip' '(' number_literal ')'
take               ::= 'take' '(' number_literal ')'

where              ::= 'where' '(' [where_arrow_func] (expr) ')' // TODO: Allowed all expressions for now, but I have to specify it to allow only comparison and boolean expressions
where_arrow_func   ::= arrow_func
private arrow_func ::= T_IDENTIFIER '=>' { pin=2 }

// Array
// ['Get haircut']
// ['Get haircut',]
// ['Get haircut', 'Bake bread', 'Eat soup']
// ['Get haircut', 'Bake bread', 'Eat soup', ['another', 'array']]
array ::= '[' array_value (',' array_value*)* ']'
private array_value ::= (string_literal | number_literal | array) ['=>' variable]

// Basic
interpolated_statement ::= '{' (antlers_expression_or_statement | expr | tag_with_attributes) '}' { pin=1 }
sub_expression ::= '(' (antlers_expression_or_statement | expr) ')' { pin=1 }
literal_expr ::= number_literal
               | boolean_literal
               | string_literal
               | variable variable_attribute_assignment*

// Literals
number_literal  ::= T_INTEGER_NUMBER | T_FLOAT_NUMBER
string_literal  ::= "'" T_STRING_CONTENT? "'"
                  | '"' T_STRING_CONTENT? '"'
boolean_literal ::= 'true' | 'false'

// Comments: {{# Here be dragons #}}
comment_block ::= T_COMMENT_OPEN T_COMMENT_TEXT* T_COMMENT_CLOSE { pin=1 }

private unclosed_comment ::= T_UNCLOSED_COMMENT

// HTML content
private outer_content ::= "@"? OUTER_CONTENT

// PHP expressions
private php_node ::= (php_raw_node | php_echo_node)
php_raw_node   ::= "{{?" T_PHP_CONTENT* "?}}" { pin=1 }
php_echo_node  ::= "{{$" T_PHP_CONTENT* "$}}" { pin=1 }

// Give the open and closing delimiter (double curly braces) a handle to be
// able refer to them on other places.
node_opener ::= T_LD
node_closer ::= T_RD


// {{ hello_world }}
// T_LD handle T_RD
// handle ::= variable

// {{ 'hello_world' }}
// T_LD handle T_RD
// handle ::= variable | string

// {{ skaters:0:name }}
// {{ skaters.1.name }}<br>
// {{ skaters[2]['name'] }}<br>
// T_LD handle [plucks] T_RD
// plucks ::= ':0' | '.0' | '[0]'
