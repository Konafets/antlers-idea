{
    parserClass="de.arrobait.antlers.parser.AntlersParser"
    parserUtilClass="de.arrobait.antlers.parser.AntlersParserUtil"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Antlers"
    psiImplClassSuffix="Impl"
    psiPackage="de.arrobait.antlers.psi"
    psiImplPackage="de.arrobait.antlers.psi.impl"

    elementTypeHolderClass="de.arrobait.antlers.psi.AntlersTypes"
    elementTypeClass="de.arrobait.antlers.psi.AntlersElementType"
    tokenTypeClass="de.arrobait.antlers.psi.AntlersTokenType"

    tokens = [
        T_COMMENT_OPEN='{{#'
        T_COMMENT_CLOSE='#}}'

        T_PHP_RAW_OPEN='{{?'
        T_PHP_RAW_CLOSE='?}}'

        T_PHP_ECHO_OPEN='{{$'
        T_PHP_ECHO_CLOSE='$}}'

        T_LD='{{'
        T_RD='}}'
        T_LP='('
        T_RP=')'
        T_LEFT_BRACE='{'
        T_RIGHT_BRACE='}'
        T_LEFT_BRACKET='['
        T_RIGHT_BRACKET=']'

        T_TRUE='true'
        T_FALSE='false'

        T_PIPE='|'

        T_COLON=':'
        T_COMMA=','
        T_DOT='.'
        T_OP_EXCLAMATION_MARK='!'
        T_OP_QUESTIONMARK='?'
        T_OP_ASSIGN='='

        // Math
        T_OP_PLUS='+'
        T_OP_MINUS='-'
        T_OP_MUL='*'
        T_SLASH='/'
        T_OP_MOD='%'
        T_OP_POW='**'
        T_OP_SELF_ASSIGN_ADD='+='
        T_OP_SELF_ASSIGN_SUB='-='
        T_OP_SELF_ASSIGN_MUL='*='
        T_OP_SELF_ASSIGN_DIV='/='
        T_OP_SELF_ASSIGN_MOD='%='

        T_OP_EQ='=='
        T_OP_NEQ='!='
        T_OP_IDENT='==='
        T_OP_NOT_IDENT='!=='
        T_OP_LT='<'
        T_OP_LTE='<='
        T_OP_GT='>'
        T_OP_GTE='>='
        T_OP_SPACESHIP='<=>'
        T_OP_NULL_COALESCENCE='??'
        T_OP_GATEKEEPER='?='

        T_OP_AND='regexp:&&|and'
        T_OP_OR='regexp:\|\||or'
        T_OP_XOR='xor'

        T_IF='if'
        T_END_IF='endif'
        T_ELSE_IF='elseif'
        T_ELSE='else'
        T_IF_END='/if'
        T_UNLESS='unless'
        T_END_UNLESS='endunless'

        T_SWITCH='switch'
        T_OP_ARROW='=>'

        T_AT='@'
        T_NOPARSE='noparse'

        T_INTEGER_NUMBER='regexp:0|[1-9]\d*'
        T_FLOAT_NUMBER='regexp:[0-9]*\.[0-9]+([eE][-+]?[0-9]+)?|[0-9]+[eE][-+]?[0-9]+'
    ]

    extends(".*expr")=expr
    extends(".*sub_expression")=expr
    extends(".*interpolated_statement")=expr
}

antlersFile ::= nodes*
private nodes ::= conditional
                | antlers_close_node
                | switch_node
                | tag_node
                | noparse_region
                | variable_assignment_node
                | recursive_children_node
                | antlers_node
                | comment_block
                | php_node
                | outer_content

// Comments: {{# Here be dragons #}}
comment_block ::= T_COMMENT_OPEN T_COMMENT_TEXT* T_COMMENT_CLOSE { pin=1 }

// HTML content
private outer_content ::= OUTER_CONTENT

// PHP expressions
private php_node ::= (php_raw_node | php_echo_node)
php_raw_node   ::= "{{?" T_PHP_CONTENT* "?}}" { pin=1 }
php_echo_node  ::= "{{$" T_PHP_CONTENT* "$}}" { pin=1 }

antlers_node ::= '{{' antlers_expression_or_statement  '}}' {
    pin=2
    recoverWhile=antlers_node_recover
}
private antlers_node_recover ::= !('{{' | outer_content | '{{#' | '{{?' | '{{$' | 'if' | 'else' | 'elseif' | 'endif' | 'unless' | 'endunless' | '/' | '[' | '{' | ':' | '=')

private antlers_expression_or_statement ::= expr ('|' modifier_list)*
antlers_close_node ::= '{{' (T_SLASH variable) '}}' { pin=2 }

// Modifier
// {{ summary | replace('It was', 'It was also') | replace('times', $noun) }}
modifier_list        ::= T_MODIFIER [modifier_params_list]
modifier_params_list ::= modifier_list_paren | modifier_list_colon | modifier_list_assign
private modifier_list_paren ::= '(' modifier_param (',' modifier_param)*  ')'
private modifier_list_colon ::= ':' modifier_param (':' modifier_param)*
// TODO For simplicity I used string_literal here as this it was the argument takes: {{ array_var modifier="param1|param2" }}
// but I guess I can improve it to let the plugin know, that this are arguments to the modifier.
// Question is: Does it blend or is should it be done on lexing or better on parsing level.
private modifier_list_assign ::= '=' string_literal
modifier_param       ::= literal_expr | array

// Tags

// Special noparse tag
noparse_region ::= noparse_region_open nodes* noparse_region_close { pin = 1 }
noparse_region_open ::= '{{' 'noparse' '}}' { pin=2 }
noparse_region_close ::= '{{' (T_SLASH 'noparse') '}}' { pin=2 }

tag_node ::= tag_node_open nodes* tag_node_close? { pin = 1 }
tag_node_open ::= '{{' [T_DISAMBIGUATION] tag_with_attributes [T_SLASH] '}}' { pin=3 }
tag_node_close ::= '{{' (T_SLASH tag) '}}' { pin=2 }

private tag_with_attributes ::= tag tag_attribute_assignment*

tag ::= shorthand_tag | regular_tag
private shorthand_tag ::= regular_tag T_SHORTHAND_SEPARATOR tag_method_part { pin=2 }
private regular_tag ::= tag_name
tag_name ::= T_TAG
tag_method_part ::= tag_method_name (T_SHORTHAND_SEPARATOR tag_method_name)*
private tag_method_name ::= T_TAG_METHOD_NAME

tag_attribute_assignment ::= T_DYNAMIC_BINDING* tag_attribute_key '=' tag_attribute_value
tag_attribute_key ::= T_IDENTIFIER
tag_attribute_value ::= string_literal

recursive_children_node ::= '{{' T_STAR T_RECURSIVE_CHILDREN [':' T_IDENTIFIER] T_STAR '}}' { pin=3 }

conditional               ::= conditional_start nodes* (conditional_elseif nodes*)* (conditional_else nodes*)? conditional_end { pin=1 }
private conditional_start ::= (conditional_if | conditional_unless)
conditional_end           ::= (slash_unless_if | endunless_endif)
conditional_if            ::= '{{' 'if' expr '}}' { pin=2 }
conditional_unless        ::= '{{' 'unless' expr '}}' { pin=2 }
conditional_elseif        ::= '{{' 'elseif' expr '}}' { pin=2 }
conditional_else          ::= '{{' 'else' '}}' { pin=2 }
private slash_unless_if   ::= '{{' (T_END_UNLESS | T_END_IF) '}}' { pin=2 }
private endunless_endif   ::= '{{' ('endunless' | 'endif') '}}' { pin=2 }

switch_node ::= '{{' switch_tag '}}' { pin=2 }
switch_tag  ::= 'switch' '(' switch_case+ ')'
switch_case ::= '(' group_comp? ')' '=>' string_literal ','? { pin=4 }

// Expressions
expr ::= interpolated_statement
       | group_bool
       | group_comp
       | group_add
       | group_mul
       | pow_expr
       | group_unary
       | concat_expr
       | group_primary
       | tenary_expr

private group_bool ::= and_expr | or_expr | xor_expr
private group_comp ::= eq_expr
                     | neq_expr
                     | ident_expr
                     | not_ident_expr
                     | lt_expr
                     | lte_expr
                     | gt_expr
                     | gte_expr
                     | spaceship_expr
                     | null_coalescing_expr
                     | gatekeeper_expr
                     | tenary_expr
private group_mul     ::= mul_expr | div_expr | mod_expr
private group_add     ::= add_expr | sub_expr
private group_unary   ::= unary_minus_expr | unary_not_expr | unary_factorial_expr
private group_primary ::= literal_expr | sub_expression

// Boolean
and_expr    ::= expr ('&&' | 'and') expr
or_expr     ::= expr ('||' | 'or') expr
xor_expr    ::= expr 'xor' expr

// Comparison
eq_expr              ::= expr '==' expr
neq_expr             ::= expr '!=' expr
ident_expr           ::= expr '===' expr
not_ident_expr       ::= expr '!==' expr
lt_expr              ::= expr '<' expr
lte_expr             ::= expr '<=' expr
gt_expr              ::= expr '>' expr
gte_expr             ::= expr '>=' expr
null_coalescing_expr ::= expr '??' expr
gatekeeper_expr      ::= expr '?=' expr
spaceship_expr       ::= expr '<=>' expr
tenary_expr ::= expr '?' expr ':' expr

// Math
mul_expr ::= expr ('*' | '*=') expr
div_expr ::= expr (T_SLASH | T_OP_SELF_ASSIGN_DIV) expr
mod_expr ::= expr ('%' | '%=') expr
add_expr ::= expr ('+' | '+=') expr
sub_expr ::= expr ('-' | '-=') expr
pow_expr ::= expr '**' expr

// Concat
concat_expr ::= string_literal '+' string_literal
              | number_literal '+' string_literal
              | string_literal '+' number_literal
              | string_literal '+' variable
              | variable ('+' | '+=') string_literal

// Unary
unary_minus_expr     ::= '-' expr
unary_not_expr       ::= '!' expr
unary_factorial_expr ::= expr '!'

// Variable
variable ::= T_IDENTIFIER [property_access*]
private property_access ::= bracket_property_access | dot_property_access | colon_property_access
bracket_property_access ::= '[' (T_INTEGER_NUMBER | T_IDENTIFIER [dot_property_access | colon_property_access] | string_literal) ']'
dot_property_access     ::= '.' (T_INTEGER_NUMBER | T_IDENTIFIER | string_literal)
colon_property_access   ::= ':' (T_INTEGER_NUMBER | T_IDENTIFIER | string_literal)

// TODO: Extract the access key into own rule
//private property_access_keys ::= T_INTEGER_NUMBER | T_IDENTIFIER | string_literal

// {{ total = 0 }}
// {{ todo = ['Get haircut', 'Bake bread', 'Eat soup'] }}
variable_assignment_node ::= '{{' variable '=' assignable_items '}}' { pin=3 }
private assignable_items ::= boolean_literal
                           | number_literal
                           | string_literal
                           | array
                           | interpolated_statement
                           | sub_expression

// Array
// ['Get haircut']
// ['Get haircut',]
// ['Get haircut', 'Bake bread', 'Eat soup']
// ['Get haircut', 'Bake bread', 'Eat soup', ['another', 'array']]
array ::= '[' array_value (',' array_value*)* ']'
private array_value ::= (string_literal | number_literal | array)

// Basic
interpolated_statement ::= '{' (antlers_expression_or_statement | expr | tag_with_attributes) '}' { pin=1 }
sub_expression ::= '(' (antlers_expression_or_statement | expr) ')' { pin=1 }
literal_expr ::= number_literal
                | boolean_literal
                | string_literal
                | variable

// Literals
number_literal  ::= T_INTEGER_NUMBER | T_FLOAT_NUMBER
string_literal  ::= T_STRING_START T_STRING_CONTENT* T_STRING_END
boolean_literal ::= 'true' | 'false'
